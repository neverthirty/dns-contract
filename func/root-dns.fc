;; Root DNS resolver in masterchain

cell load_data() inline {
    return get_data().begin_parse().preload_dict(); ;; hashmap with addresses of contracts of root domain zones
}

(int, cell) dnsresolve(slice subdomain, int category) method_id {
    throw_unless(70, mod(slice_bits(subdomain), 8) == 0);

    int starts_with_zero_byte = subdomain.preload_int(8) == 0;

    if (starts_with_zero_byte & (slice_bits(subdomain) == 8)) { ;; "." requested
        return (8, null()); ;; resolved but no dns-records
    }
    if (starts_with_zero_byte) {
        subdomain~load_uint(8);
    }

    int top_subdomain_bits = get_top_domain_bits(subdomain);
    slice top_subdomain = subdomain~load_bits(top_subdomain_bits);

    int top_subdomain_hash = slice_hash(top_subdomain);
    int top_subdomain_bits = slice_bits(top_subdomain);

    (slice next_resolver_addresses, int r) = udict_get?(load_data(), 256, top_subdomain_hash);
    if (~ r) {
        return (0, null()); ;; domain cannot be resolved
    }

    cell result = begin_cell()
            .store_uint(dns_next_resolver_prefix, 16)
            .store_slice(next_resolver_addresses)
            .end_cell();

    return (top_subdomain_bits + (starts_with_zero_byte ? 8 : 0), result);
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
}